## redis 完成定时任务的场景
### redies概念 
发布订阅机制（pub | sub）  
过期通知
### 常用应用场景
   订单模块 与 评论模块，都会涉及到定时任务执行   
比如：  
- 用户下订单后，需要在15分钟内完成支付，否则订单失效关闭。
- 用户在完成订单后，如果没有人评论，过对应时间后，系统自动评论，并且完结。（为了防止尴尬、假象）
### 解决思路
- 第一种：延迟解决法
在订单的信息中，加入过期时间。当用户查询订单或者做其他操作的时候，检查一下有没有过期的预选订单
- 第二种：轮询法
启动一个定时线程，每隔一段时间遍历一次订单信息，如果有到期的，则结束订单。但是这种方法会影响性能
- 第三种：redis的key过期解决
命令（expire）：设置 key 的过期时间。  
订阅->接受到key的过期提醒->执行取消订单逻辑。
```
redis 定时器demo演示：

配置文件 + notify-keyspace-events Ex
开启过期通知功能

-- __keyevent@0__:expired
订阅频道

-- set demo tom EX 30
设置demo（key）的过期时间为 30 秒
OK

-- get demo
(nil)
-- 配置文件 + notify-keyspace-events Ex

收到消息
"pmessage"
"__keyevent@0__:expired"
"__keyevent@0__:expired"
"demo"

```
[分布式锁的案例](https://www.cnblogs.com/ztfjs/p/redis-lock.html)
- 第四种：[redisson延迟队列](https://zhuanlan.zhihu.com/p/107624995)
```
redisson延迟队列demo演示：

-- 导入redissonn包

-- SpringBoot的Redis配置
spring.redis.host=192.168.1.100
spring.redis.port=6379

-- 封装的工具类


-- 运行并测试

```
封装的工具类 
```java
@Service
public class RedisDelayedQueue {

    /**
     * 任务回调监听
     *
     * @param <T>
     */
    public abstract static class TaskEventListener<T> {
        /**
         * 执行方法
         *
         * @param t
         */
        public abstract void invoke(T t);
    }

    @Autowired
    RedissonClient redissonClient;

    /**
     * 添加队列
     *
     * @param t        DTO传输类
     * @param delay    时间数量
     * @param timeUnit 时间单位
     * @param <T>      泛型
     */
    public <T> void addQueue(T t, long delay, TimeUnit timeUnit) {
        RBlockingQueue<T> blockingFairQueue = redissonClient.getBlockingQueue(t.getClass().getName());
        RDelayedQueue<T> delayedQueue = redissonClient.getDelayedQueue(blockingFairQueue);
        delayedQueue.offer(t, delay, timeUnit);
        delayedQueue.destroy();
    }

    /**
     * 获取队列
     *
     * @param zClass            DTO泛型
     * @param taskEventListener 任务回调监听
     * @param <T>               泛型
     * @return
     */
    public <T> void getQueue(Class zClass, TaskEventListener taskEventListener) {
        RBlockingQueue<T> blockingFairQueue = redissonClient.getBlockingQueue(zClass.getName());
        //由于此线程需要常驻，可以新建线程，不用交给线程池管理
        ((Runnable) () -> {
            while (true) {
                try {
                    T t = blockingFairQueue.take();
                    taskEventListener.invoke(t);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).run();
    }
}
```
测试类
```java
TaskBodyDTO taskBody = new TaskBodyDTO();
taskBody.setBody("测试DTO实体类的BODY,3秒之后执行");
redisDelayedQueue.addQueue(taskBody, 3, TimeUnit.SECONDS); 
 //监听延迟队列
  RedisDelayedQueue.TaskEventListener<TaskBodyDTO> taskEventListener = new RedisDelayedQueue.TaskEventListener<TaskBodyDTO>() {
            @Override
            public void invoke(TaskBodyDTO taskBodyDTO) {
                //这里调用你延迟之后的代码
                logger.info("执行...." + taskBodyDTO.getBody() + "===" + taskBodyDTO.getName());
            }
        };
        redisDelayedQueue.getQueue(TaskBodyDTO.class, taskEventListener);

```
